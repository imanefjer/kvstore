!!!!! Read levelDB
curl "http://localhost:8084/get?key=4"
curl -X POST -H "Content-Type: application/json" -d @data.json http://localhost:8084/test
curl -X DELETE "http://localhost:8084/del?key=key1"

go build 
kvstore.exe

json it will be needed in testing


if i don't have goroutine i should delete mu mutex
LSM tree // b+ tree LSM hssn
////
A sequentially-written file refers to a file where data is written sequentially or in a continuous manner without random access.
 In the context of a key-value store or database system, this often relates to the order in which data is appended to the file.

When dealing with sequential writes:

Appending Data: New data is added to the file by appending it at the end. This is a common practice for write-ahead logs (WAL) 
or logs in databases.

No Random Access: Unlike a random access file where you can seek to any position to read or write data, in a 
sequentially-written file, you typically read and write data in a linear fashion, from the beginning to the end.

Write-Once: Once data is written, it is not typically modified in place. If modifications are needed, a new version or entry is 
appended to the file.

Sequentially-written files are often used for operations like logging, where the order of events is crucial, or for write-ahead 
logs in databases, where maintaining the order of write operations is essential for durability and consistency.*
////
///
WAL can be configured to be stored in a directory different from the directory where the SST files are stored. This is necessary
 for those cases in which you might want to store all data files in non-persistent fast storage. At the same time, you can 
 ensure no data loss by putting all transaction logs on slower but persistent storage.
///
Memtables in memeory after flash they will be  SStables 
WAL (log) (clean the WAL )
SSTables has a tuples
delete file
level DB LSMtrees

Compactions

- compaction is the process of merging multiple sstables into one or more new sstable(s).
- compactions are triggered by space amplification, i.e., when an sstable grows beyond its configured size limit, it triggers 
a compaction
**copilot generate this:
//Compactions
//Read/Write Amplification
//Data modeling and indexing
//Cassandra vs. HBase**


API
memDb (map that sorted the key values) 
WAL (Set k, v)appendOnly 
flashing to sstables
crash recovery
restart first ting read wal mn watermark

compactions we can use a go routine

while flashing the desk atomic (file rename in a temporary dir )

testing 
documentation
ga
SStable (metadata: length of key, value, magic number o cafebyte, offset dlmin key, dlmax key, num of tuples , timestamp, 
version, hash (,uc21E) ) binary files
we can not use timestamp if the name of the 
var length encoding 
lkeys ou lvalues strings
utfas
bloom filter

min key and max keyoffset is used to see if a key is in that file
compression is bonus 
we add a byte to see if it is deleted or Set
(T, lengthof the key, key, lengthos the value, value)
t to see if the value is deleted or not


linear search
system dalk ghaywli false tolerant(3 node)optional

Nodes (three nodes)




//bloom filter
//indexes
//data modeling
//caching
//compression
//read amplification
//write amplification
//garbage collection
//recovery
//backup
//replication
//sharding
//partitioning
//distributed systems
//consistency models
//transactional systems
//eventual consistency
//strong consistency
//serializable isolation
